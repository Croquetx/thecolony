  /*--------------------------------- * The Animator * Copyright 1988 by David A. Smith * All Rights Reserved * 111 Gold Meadow Dr. * Cary, NC 27513 *---------------------------------*//*---------------------------------------------------------------------- *	spritePlane.c * * 	Functions to create and edit animated displays used by THE GAME. *	Copyright 1985 by David A. Smith *---------------------------------------------------------------------- */#define EXT extern #include "adefs.h"/*---------------------------------------------------------------------- * NOTE:Each sprite only keeps track of those sprites which are on top *		of it.  Thus, when you erase a sprite it has a record of all  *		the sprites on top of it that need to be erased first.  When the *		sprite is drawn, all of those sprites beneath it need to be *		checked and at that time their records are updated. *---- low level routines not callable by user ---- * DrawlSprite(int snum) * EraselSprite(int snum) * EraseTree(int snum) * DrawTree(int snum) *---- hi level routines callable by user ---- * SpritePaste(Rect *loc); * MovelSprite(Point *p,int num); * KilllSprite(int num); * DrawPlane() * ErasePlane() * DoSPlanes(Point *p,int num); * MoveSObject(Point *p); * KillSObject(Point *p); * int WhichlSprite(Point *p,int *ploc); *---------------------------------------------------------------------- *//*----------------------------------------------------------------------*//*----------------------------------------------------------------------*/int FindSprite(snum,pr)int snum;Rect *pr;{int cnum,xloc,yloc;cnum=lSprite[snum].current;xloc=lSprite[snum].xloc + lSprite[snum].object[cnum].xloc;yloc=lSprite[snum].yloc + lSprite[snum].object[cnum].yloc;cnum=lSprite[snum].object[cnum].spritenum;pr->top=cSprite[cnum].clip.top+yloc;pr->left=cSprite[cnum].clip.left+xloc;pr->bottom=cSprite[cnum].clip.bottom+yloc;pr->right=cSprite[cnum].clip.right+xloc;return(cnum);/*return the sprite number*/}/*----------------------------------------------------------------------*//*----------------------------------------------------------------------*/int Overlap(i,j){Rect r0,r1,dummy;int cnum;int xloc,yloc;FindSprite(i,&r0);FindSprite(j,&r1);return(SectRect(&r0,&r1,&dummy));}/*----------------------------------------------------------------------*//*----------------------------------------------------------------------*/DrawlSprite(snum)int snum;{int i;int bit=1<<snum;GrafPtr	savePort;int cnum;Rect locate,clip;int sloc;GetPort( &savePort );/*save the current background*/cnum=FindSprite(snum,&locate);if(locate.top<0)	{	sloc=locate.top;	clip.bottom=cSprite[cnum].clip.bottom;	clip.left=cSprite[cnum].clip.left;	clip.right=cSprite[cnum].clip.right;	clip.top=-locate.top;	locate.top=0;	CopyBits(&meta0.portBits,lSprite[snum].bg,		&locate,&clip,		srcCopy,NIL);	locate.top=sloc;	}else	{	CopyBits(&meta0.portBits,lSprite[snum].bg,		&locate,&cSprite[cnum].clip,		srcCopy,NIL);	}SetPort(&meta0);ClipRect(&DClip);CopyBits(cSprite[cnum].mask,	&meta0.portBits,	&cSprite[cnum].clip,&locate,	srcBic,NIL);CopyBits(cSprite[cnum].fg,	&meta0.portBits,	&cSprite[cnum].clip,&locate,	srcOr,NIL);ClipRect(&size);lSprite[snum].visible=TRUE;ClipRect(&size);SetPort( savePort );}/*----------------------------------------------------------------------*/EraselSprite(snum)int snum;{int j;GrafPtr	savePort;Rect locate;int bit=~(1<<snum);int cnum;GetPort( &savePort );SetPort(&meta0);lSprite[snum].visible=FALSE;cnum=FindSprite(snum,&locate);ClipRect(&DClip);CopyBits(lSprite[snum].bg,	&meta0.portBits,	&cSprite[cnum].clip,	&locate,	srcCopy,NIL);ClipRect(&size);SetPort( savePort );}/*----------------------------------------------------------------------*/EraseTree(snum)int snum;{int i;	for(i=(maxSprite-1);i>snum;i--)	if(lSprite[i].visible)		if(Overlap(snum,i))			EraseTree(i);if(lSprite[snum].visible)EraselSprite(snum);}/*----------------------------------------------------------------------*/DrawTree(snum)int snum;{int i;for(i=snum;i<maxSprite;i++)if(!lSprite[i].visible)DrawlSprite(i);}/*----------------------------------------------------------------------*/extern BitMap* MakeBitMap();SpritePaste(loc)Rect *loc;{Point p;if(maxSprite==32){SysBeep(10); return;}SetPort(theWindow);p.v=loc->top;p.h=loc->left;GlobalToLocal(&p);lSprite[maxSprite].size=1;lSprite[maxSprite].current=0;lSprite[maxSprite].acurrent=0;lSprite[maxSprite].ayloc=lSprite[maxSprite].yloc=p.v;lSprite[maxSprite].axloc=lSprite[maxSprite].xloc=p.h;lSprite[maxSprite].object[0].spritenum=locSprite;cSprite[locSprite].used++;lSprite[maxSprite].bg=MakeBitMap(&cSprite[locSprite].clip);lSprite[maxSprite].visible=TRUE;lSprite[maxSprite].type=0;/*key or object*/lSprite[maxSprite].frozen=0;lSprite[maxSprite].locked=0;lSprite[maxSprite].link=0; /*size of object or control state*/lSprite[maxSprite].key=0;/*also acts as object numbers if container*/lSprite[maxSprite].lock=0;DrawlSprite(maxSprite);DejaDCopy();SetPort(animWindow);if(maxSprite)InvertRect(&dbutton[lSprite[anum].acurrent]);anum=maxSprite;DrawInfo();SetPort(theWindow);DrawBackGround(&meta1);DrawAnim();AnimDCopy();maxSprite++;DrawSprite();changed=TRUE;}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */MovelSprite(p,num)Point *p;int num;{Rect r,dummy;Point new,old;int i;int xloc,yloc;old.v=p->v;old.h=p->h;while(Button())	{	GetMouse(&new);	if(new.v>0&&new.v<(HEIGHT-BTOP)&&new.h>0&&new.h<WIDTH)	if(new.v!=old.v || new.h!=old.h)		{		EraseTree(num);		lSprite[num].xloc+=new.h-old.h;		lSprite[num].yloc+=new.v-old.v;		EraseTree(num);		old.h=new.h;		old.v=new.v; 		DrawTree(num);		DejaDCopy();		}	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */KilllSprite(num)int num;{int i,j;DrawBackGround(&meta0);for(i=0;i<maxSprite;i++){lSprite[i].visible=0;}for(i=0;i<lSprite[num].size;i++)	cSprite[lSprite[num].object[i].spritenum].used--;KillBitMap(lSprite[num].bg); for(i=num+1;i<maxSprite;i++)	CopylSprite(i-1,i);maxSprite--;DrawPlane();/*draw in the foreground*/DejaDCopy();DrawSprite();SetPort(animWindow);if(maxSprite)DrawInfo();DrawBackGround(&meta1);if(maxSprite)	{	if(anum==maxSprite)anum--;	DrawAnim();	AnimDCopy();	if(maxSprite)DrawInfo();	}else	{	AnimDCopy();	}SetPort(theWindow);}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */DrawPlane(){GrafPtr	savePort;int i;struct oSprite *savesprite;int *savemax;GetPort( &savePort );SetPort(&meta0);for(i=0;i<maxSprite;i++){lSprite[i].visible=0;}for(i=0;i<maxSprite;i++)DrawlSprite(i);SetPort(savePort);}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */DoSPlanes(p,num)Point *p;int num;{switch(num)	{	case 0:/*move around*/		MoveSObject(p);		break;	case 1:/*erase object*/		KillSObject(p);		break;	case 2:			UpOne(p);		break;	case 3:		DownOne(p);		break;	case 4:			UpTop(p);		break;	case 5:		DownBottom(p);		break;	case 6:		Clone(p);		break;	case 7:		DoIt(p);		break;	}changed=TRUE;}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */MoveSObject(p)Point *p;{int num,loc,current;num=WhichlSprite(p,&loc);if(loc)	{	if(doubleclick())		{		SetPort(animWindow);		if(maxSprite)InvertRect(&dbutton[lSprite[anum].acurrent]);		anum=num;		DrawBackGround(&meta1);		DrawAnim();		AnimDCopy();		if(maxSprite)DrawInfo();		SetPort(theWindow);		}	else MovelSprite(p,num);	}else MoveBG(p);}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */KillSObject(p)Point *p;{int num;int loc;num=WhichlSprite(p,&loc);if(loc)KilllSprite(num);}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */UpOne(p)Point *p;{int num,loc;num=WhichlSprite(p,&loc);if(loc && num!=(maxSprite-1))	{	EraseTree(num);	SwitchlSprite(num,num+1);	EraseTree(num);	DrawTree(num);	DejaDCopy();	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */DownOne(p)Point *p;{int num,loc;num=WhichlSprite(p,&loc);if(loc && num!=0)	{	EraseTree(num-1);	SwitchlSprite(num-1,num);	EraseTree(num-1);	DrawTree(num-1);	DejaDCopy();	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */UpTop(p)Point *p;{int num,loc,i;num=WhichlSprite(p,&loc);if(loc && num!=(maxSprite-1))	{	for(i=num;i<(maxSprite)-1;i++)EraseTree(i);	for(i=num;i<(maxSprite)-1;i++)SwitchlSprite(i,i+1);	for(i=num;i<(maxSprite)-1;i++)EraseTree(i);	DrawTree(num);	DejaDCopy();	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */DownBottom(p)Point *p;{int num,loc;int i;num=WhichlSprite(p,&loc);if(loc && num!=0)	{	for(i=num;i>0;i--)EraseTree(i);	for(i=num;i>0;i--)		SwitchlSprite(i,i-1);	for(i=num;i>0;i--)EraseTree(i);	DrawTree(0);	DejaDCopy();	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */Clone(p)Point *p;{int num;int loc;int i;if(maxSprite==32){SysBeep(10); return;}num=WhichlSprite(p,&loc);if(loc)	{	lSprite[maxSprite].size=lSprite[num].size;	lSprite[maxSprite].current=lSprite[num].current;	lSprite[maxSprite].acurrent=lSprite[num].acurrent;	lSprite[maxSprite].ayloc=lSprite[num].ayloc+16;	lSprite[maxSprite].yloc=lSprite[num].yloc+16;	lSprite[maxSprite].axloc=lSprite[num].axloc+16;	lSprite[maxSprite].xloc=lSprite[num].xloc+16;	for(i=0;i<lSprite[num].size;i++)		{		lSprite[maxSprite].object[i].spritenum=lSprite[num].object[i].spritenum;		cSprite[lSprite[maxSprite].object[i].spritenum].used++;		lSprite[maxSprite].object[i].xloc=lSprite[num].object[i].xloc;		lSprite[maxSprite].object[i].yloc=lSprite[num].object[i].yloc;		}	lSprite[maxSprite].bg=MakeBitMap(&lSprite[num].bg->bounds);	lSprite[maxSprite].visible=TRUE;	lSprite[maxSprite].type=lSprite[num].type;/*key or object*/	lSprite[maxSprite].frozen=lSprite[num].frozen;	lSprite[maxSprite].locked=lSprite[num].locked;	lSprite[maxSprite].link=lSprite[num].link; /*size of object or control state*/	lSprite[maxSprite].key=lSprite[num].key;/*also acts as object numbers if container*/	lSprite[maxSprite].lock=lSprite[num].lock;	SetPort(animWindow);	DrawInfo();	DrawlSprite(maxSprite);	DejaDCopy();	anum=maxSprite;	DrawInfo();	DrawBackGround(&meta1);	DrawAnim();	AnimDCopy();	maxSprite++;	DrawSprite();	SetPort(theWindow);	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */int WhichlSprite(p,ploc)Point *p;int *ploc;{int i;int num;GrafPtr temp;GrafPtr	savePort;Rect r;int cnum;GetPort( &savePort );temp=(GrafPtr)NewPtr((long)sizeof(GrafPort));OpenPort(temp);*ploc=0;for(i=(maxSprite)-1;i>=0;i--)	{	cnum=FindSprite(i,&r);	if( p->h>=r.left &&		p->h<=r.right &&		p->v>=r.top &&		p->v<=r.bottom)		{		SetPortBits(cSprite[cnum].mask);		if(GetPixel(p->h-r.left,					p->v-r.top))			{			num=i;			*ploc=1;			break;			}		}	}ClosePort(temp);DisposPtr(temp);SetPort(savePort);return(num);}/*----------------------------------------------------------------------*/extern BitMap* MakeBitMap();SwitchlSprite(s1,s2)int s1,s2;{struct oSprite temp;int i;if(anum==s1 || anum==s2)	{	SetPort(animWindow);	if(maxSprite)DrawInfo();	SetPort(theWindow);	}temp.size=lSprite[s1].size;temp.current=lSprite[s1].current;temp.xloc=lSprite[s1].xloc;temp.yloc=lSprite[s1].yloc;temp.acurrent=lSprite[s1].acurrent;temp.axloc=lSprite[s1].axloc;temp.ayloc=lSprite[s1].ayloc;for(i=0;i<lSprite[s1].size;i++)	{	temp.object[i].xloc=lSprite[s1].object[i].xloc;	temp.object[i].yloc=lSprite[s1].object[i].yloc;	temp.object[i].spritenum=lSprite[s1].object[i].spritenum;	}temp.bg=lSprite[s1].bg;temp.visible=lSprite[s1].visible;temp.type=lSprite[s1].type;/*key or object*/temp.frozen=lSprite[s1].frozen;temp.locked=lSprite[s1].locked;temp.link=lSprite[s1].link; /*size of object or control state*/temp.key=lSprite[s1].key;/*also acts as object numbers if container*/temp.lock=lSprite[s1].lock;lSprite[s1].size=lSprite[s2].size;lSprite[s1].current=lSprite[s2].current;lSprite[s1].xloc=lSprite[s2].xloc;lSprite[s1].yloc=lSprite[s2].yloc;lSprite[s1].acurrent=lSprite[s2].acurrent;lSprite[s1].axloc=lSprite[s2].axloc;lSprite[s1].ayloc=lSprite[s2].ayloc;for(i=0;i<lSprite[s2].size;i++)	{	lSprite[s1].object[i].spritenum=lSprite[s2].object[i].spritenum;	lSprite[s1].object[i].xloc= lSprite[s2].object[i].xloc;	lSprite[s1].object[i].yloc=	lSprite[s2].object[i].yloc;	}lSprite[s1].bg=lSprite[s2].bg;lSprite[s1].visible=lSprite[s2].visible;lSprite[s1].type=lSprite[s2].type;/*key or object*/lSprite[s1].frozen=lSprite[s2].frozen;lSprite[s1].locked=lSprite[s2].locked;lSprite[s1].link=lSprite[s2].link; /*size of object or control state*/lSprite[s1].key=lSprite[s2].key;lSprite[s1].lock=lSprite[s2].lock;lSprite[s2].size=temp.size;lSprite[s2].current=temp.current;lSprite[s2].xloc=temp.xloc;lSprite[s2].yloc=temp.yloc;lSprite[s2].acurrent=temp.acurrent;lSprite[s2].axloc=temp.axloc;lSprite[s2].ayloc=temp.ayloc;for(i=0;i<temp.size;i++)	{	lSprite[s2].object[i].spritenum=temp.object[i].spritenum;	lSprite[s2].object[i].xloc=   	temp.object[i].xloc;	lSprite[s2].object[i].yloc=		temp.object[i].yloc;	}lSprite[s2].bg=temp.bg;lSprite[s2].visible=temp.visible;lSprite[s2].type=temp.type;/*key or object*/lSprite[s2].frozen=temp.frozen;lSprite[s2].locked=temp.locked;lSprite[s2].link=temp.link; /*size of object or control state*/lSprite[s2].key=temp.key;lSprite[s2].lock=temp.lock;if(anum==s1 || anum==s2)	{	SetPort(animWindow);	if(anum==s1)anum=s2;	else if(anum==s2)anum=s1;	if(maxSprite)DrawInfo();	DrawBackGround(&meta1);	DrawAnim();	AnimDCopy();	SetPort(theWindow);	}}/*----------------------------------------------------------------------*/CopylSprite(s1,s2)int s1,s2;{int i;lSprite[s1].size=lSprite[s2].size;lSprite[s1].current=lSprite[s2].current;lSprite[s1].xloc=lSprite[s2].xloc;lSprite[s1].yloc=lSprite[s2].yloc;lSprite[s1].acurrent=lSprite[s2].acurrent;lSprite[s1].axloc=lSprite[s2].axloc;lSprite[s1].ayloc=lSprite[s2].ayloc;for(i=0;i<lSprite[s2].size;i++)	{	lSprite[s1].object[i].spritenum=    lSprite[s2].object[i].spritenum;	lSprite[s1].object[i].xloc=   lSprite[s2].object[i].xloc;	lSprite[s1].object[i].yloc=lSprite[s2].object[i].yloc;	}lSprite[s1].bg=lSprite[s2].bg;lSprite[s1].visible=lSprite[s2].visible;lSprite[s1].type=lSprite[s2].type;/*key or object*/lSprite[s1].frozen=lSprite[s2].frozen;lSprite[s1].locked=lSprite[s2].locked;lSprite[s1].link=lSprite[s2].link;lSprite[s1].key=lSprite[s2].key;lSprite[s1].lock=lSprite[s2].lock;}/*----------------------------------------------------------------------*/CopySpritenum(to,from)int to,from;{int i,j;for(i=0;i<maxSprite;i++)	for(j=0;j<lSprite[i].size;j++)		if(lSprite[i].object[j].spritenum==from)			lSprite[i].object[j].spritenum=to;}/*----------------------------------------------------------------------*/int doubleclick(){long uptime,clicktime,getdbltime();EventRecord upevent,downevent;uptime=key.when+getdbltime();while(TickCount()<uptime);if(GetNextEvent(mUpMask,&upevent))	{	clicktime=upevent.when+getdbltime();	while(TickCount()<clicktime);	if(GetNextEvent(mDownMask,&downevent))return(TRUE);	}return(FALSE);}/*----------------------------------------------------------------------*/long getdbltime(){/*return double click time from global variable*/return(*((long *)0x02F0));}/*----------------------------------------------------------------------*/ShowIt(){int i;for(i=0;i<maxSprite;i++)	{	if(lSprite[i].type==0&&!lSprite[i].locked)		{		EraseTree(i);		lSprite[i].current++;		if(lSprite[i].current==lSprite[i].size)lSprite[i].current=0;		EraseTree(i);		}	}for(i=0;i<maxSprite;i++)	if(lSprite[i].type==0)		DrawTree(i);DejaDCopy();}/*----------------------------------------------------------------------*/NoShowIt(){int i;for(i=0;i<maxSprite;i++)	{	if(lSprite[i].type==0&&!lSprite[i].locked)		{		EraseTree(i);		lSprite[i].current++;		if(lSprite[i].current==lSprite[i].size)lSprite[i].current=0;		EraseTree(i);		}	}}/*----------------------------------------------------------------------*/DoIt(p)Point *p;{int num,loc,current;num=WhichlSprite(p,&loc);if(loc)DolSprite(p,num);}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */DolSprite(p,num)Point *p;int num;{Rect r,dummy;Point new,old;int xloc,yloc;int savenum;int i,knum,oldknum=-1;int loc;old.v=p->v;old.h=p->h;switch(lSprite[num].type)	{	case 0:/*displays*/		if(!lSprite[num].frozen)			{			while(Button())/*this is a display - animate always*/				{				GetMouse(&new);				NoShowIt();				if(new.v>0&&new.v<(HEIGHT-BTOP)&&new.h>0&&new.h<WIDTH)					{					EraseTree(num);					lSprite[num].current++;					if(lSprite[num].current==lSprite[num].size)lSprite[num].current=0;					lSprite[num].xloc+=new.h-old.h;					lSprite[num].yloc+=new.v-old.v;					if(lSprite[num].link)						{						for(i=0;i<maxSprite;i++)							{							if(lSprite[i].link==lSprite[num].link && num!=i)								{								EraseTree(i);								lSprite[i].xloc+=new.h-old.h;								lSprite[i].yloc+=new.v-old.v;								EraseTree(i);								}							}						}					EraseTree(num);					old.h=new.h;					old.v=new.v; 					}				DrawTree(0);				DejaDCopy();				}			NoShowIt();			EraseTree(num);/*reset key to original state*/			lSprite[num].current=0;			EraseTree(num);			DrawTree(0);			DejaDCopy();			}		break;	case 1:/*key and control*/		if(lSprite[num].frozen)/*this is a control*/			{			if((!lSprite[num].locked)||lSprite[num].current)			while (Button())				{				savenum=lSprite[num].current;				GetMouse(&new);				NoShowIt();				EraseTree(num);				if(!InsideControl(&new,num))/*not inside the current sprite*/					{					while((--lSprite[num].current)>=0)/*check previous sprites*/						if(InsideControl(&new,num))break;					if(lSprite[num].current<0)						{						lSprite[num].current=savenum;						while((++lSprite[num].current)<lSprite[num].size)							if(InsideControl(&new,num))break;						if(lSprite[num].current==lSprite[num].size)							lSprite[num].current=savenum;						}					}				if(lSprite[num].key)					for(i=0;i<maxSprite;i++)if(i!=num)						if(lSprite[i].lock==lSprite[num].key)							{							EraseTree(i);							lSprite[i].current=lSprite[num].current;							if(lSprite[i].current>=lSprite[i].size)								lSprite[i].current=lSprite[i].size-1;							EraseTree(i);							}				EraseTree(num);				DrawTree(0);				DejaDCopy();				}			}		else 			{			while(Button())/*this is a key - animate always*/				{				GetMouse(&new);				NoShowIt();				if(new.v>0&&new.v<(HEIGHT-BTOP)&&new.h>0&&new.h<WIDTH)					{					EraseTree(num);					lSprite[num].current++;					if(lSprite[num].current==lSprite[num].size)lSprite[num].current=0;					lSprite[num].xloc+=new.h-old.h;					lSprite[num].yloc+=new.v-old.v;					EraseTree(num);					knum=KeylSprite(num,&new,&loc);					if(loc)					if(knum!=oldknum)						{						if(lSprite[knum].current==1)							{							NoShowIt();							EraseTree(knum);							lSprite[knum].current--;							EraseTree(knum);							EraseTree(num);							lSprite[num].current++;							if(lSprite[num].current==lSprite[num].size)lSprite[num].current=0;							EraseTree(num);							DrawTree(0);							DejaDCopy();							}						else if(lSprite[knum].current==0)							{							NoShowIt();							EraseTree(knum);							lSprite[knum].current++;							EraseTree(knum);							EraseTree(num);							lSprite[num].current++;							if(lSprite[num].current==lSprite[num].size)lSprite[num].current=0;							EraseTree(num);							DrawTree(0);							DejaDCopy();							}						oldknum=knum;						}					old.h=new.h;					old.v=new.v;					}				DrawTree(0);				DejaDCopy();				}			NoShowIt();			EraseTree(num);/*reset key to original state*/			lSprite[num].current=0;			EraseTree(num);			DrawTree(0);			DejaDCopy();			}		break;	case 2:/*container and object*/		if(lSprite[num].frozen)			{			if(!lSprite[num].locked)				/*this is a container--only can open or close*/				{				if(lSprite[num].current) while(lSprite[num].current>0)					{					NoShowIt();					EraseTree(num);					lSprite[num].current--;					EraseTree(num);					DrawTree(0);					DejaDCopy();					}				else while(lSprite[num].current<lSprite[num].size-1)					{					NoShowIt();					EraseTree(num);					lSprite[num].current++;					EraseTree(num);					DrawTree(0);					DejaDCopy();					}				}			else				/*this is a container--only can open or close*/				{				if(lSprite[num].current>1) while(lSprite[num].current>0)					{					NoShowIt();					EraseTree(num);					lSprite[num].current--;					EraseTree(num);					DrawTree(0);					DejaDCopy();					}				else if(lSprite[num].current==1)while(lSprite[num].current<lSprite[num].size-1)					{					NoShowIt();					EraseTree(num);					lSprite[num].current++;					EraseTree(num);					DrawTree(0);					DejaDCopy();					}				}			}		else while(Button())/*this is an object - only allow the user to move it*/			{			GetMouse(&new);			NoShowIt();			if(new.v>0&&new.v<(HEIGHT-BTOP)&&new.h>0&&new.h<WIDTH)				{				EraseTree(num);				lSprite[num].xloc+=new.h-old.h;				lSprite[num].yloc+=new.v-old.v;				EraseTree(num);				if(lSprite[num].link)					for(i=0;i<maxSprite;i++)						{						if(lSprite[i].link==lSprite[num].link && num!=i)							{							EraseTree(i);							lSprite[i].xloc+=new.h-old.h;							lSprite[i].yloc+=new.v-old.v;							EraseTree(i);							}						}				old.h=new.h;				old.v=new.v; 				}			DrawTree(0);			DejaDCopy();			}		break;	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */int InsideControl(p,num)Point *p;int num;{GrafPtr temp;GrafPtr	savePort;Rect r;int cnum;int inside=FALSE;GetPort( &savePort );temp=(GrafPtr)NewPtr((long)sizeof(GrafPort));OpenPort(temp);cnum=FindSprite(num,&r);if( p->h>=r.left &&	p->h<=r.right &&	p->v>=r.top &&	p->v<=r.bottom)	{	SetPortBits(cSprite[cnum].mask);	if(GetPixel(p->h-r.left,p->v-r.top))inside=TRUE;	}ClosePort(temp);DisposPtr(temp);SetPort(savePort);return(inside);}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */int KeylSprite(key,p,ploc)int key;Point *p;int *ploc;{int i;GrafPtr temp;GrafPtr	savePort;Rect r;int cnum;int num;GetPort( &savePort );temp=(GrafPtr)NewPtr((long)sizeof(GrafPort));OpenPort(temp);*ploc=0;for(i=(maxSprite)-1;i>=0;i--)if(key!=i)if(lSprite[i].lock==lSprite[key].key)	{	cnum=FindSprite(i,&r);	if( p->h>=r.left &&		p->h<=r.right &&		p->v>=r.top &&		p->v<=r.bottom)		{		SetPortBits(cSprite[cnum].mask);		if(GetPixel(p->h-r.left,					p->v-r.top))			{			num=i;			*ploc=1;			break;			}		}	}ClosePort(temp);DisposPtr(temp);SetPort(savePort);return(num);}