/*--------------------------------- * The Animator * Copyright 1988 by David A. Smith * All Rights Reserved * 111 Gold Meadow Dr. * Cary, NC 27513 *---------------------------------*/#define EXT extern #include "adefs.h"WindowRecord sRecord;Rect scBounds;/*--------------------------------------------------------------------- * InitSprite() *--------------------------------------------------------------------- */extern BitMap* MakeBitMap();/*BitMap* offScreenBits;*/InitSprite(){Rect r;int i;locSprite=0;/*offScreenBits=MakeBitMap(&screenBits.bounds);*/SetRect(&r, 4, 230, 86, 340);SetPort((sWindow = NewWindow( &sRecord , &r, "\pSprites",	1, 0, -1L, 0, 0L)));SetPort(sWindow);DrawGrowIcon(sWindow);SetRect(&scBounds,	sWindow->portRect.left-1,	sWindow->portRect.bottom-15,	sWindow->portRect.right-14,	sWindow->portRect.bottom+1);sControl=NewControl(sWindow,&scBounds,"\p",TRUE,0,0,0,16,0L);TextFont(0);DrawSprite();HiliteControl(sControl,0);}/*----------------------------------------------------------------------*/SUpdate(){GrafPtr	savePort;Rect clip;GetPort( &savePort );SetPort(sWindow);BeginUpdate(sWindow);DrawGrowIcon(sWindow);DrawControls(sWindow);DrawSprite();EndUpdate(sWindow);SetPort( savePort );}/*----------------------------------------------------------------------*/DoGrowThing(where)Point   *where;{Rect    bounds;long    result_size;GrafPtr	savePort;Rect clip;GetPort( &savePort );SetPort(sWindow);SetRect(&bounds, 70, 70, 505, 299);	/* Slightly arbitrary */result_size = GrowWindow(sWindow, where, &bounds);if (! result_size)return;SizeWindow(sWindow, (int)(result_size & 0xffff), 	(int)(result_size >> 16), 0);HideControl(sControl);ClipRect(&sWindow->portRect);EraseRect(&sWindow->portRect);DrawGrowIcon(sWindow);ResizeControl();ShowControl(sControl);HiliteControl(sControl,0);DrawSprite();SetPort( savePort );}/*----------------------------------------------------------------------*/ResizeControl(){SetRect(&(*sControl)->contrlRect,	sWindow->portRect.left-1,	sWindow->portRect.bottom-15,	sWindow->portRect.right-14,	sWindow->portRect.bottom+1);}/*----------------------------------------------------------------------*/SetClipRect(pr)Rect *pr;{pr->left=sWindow->portRect.left;pr->right=sWindow->portRect.right;pr->top=sWindow->portRect.top;pr->bottom=sWindow->portRect.bottom-15;}/*----------------------------------------------------------------------*/doscrolling(){int i,current;int clip;locSprite=GetCtlValue(sControl);for(i=0;i<10000;i++);DrawSprite();}/*----------------------------------------------------------------------*/int     stepsize = 1;int     pagestep = 1;int		count=0;pascal void trackscroll(control, partcode)ControlHandle   control;int             partcode;{if(maxsprite<=0)return;if (partcode == 0)    return;switch (partcode)	{	case inUpButton:	    stepsize = -1;	    break;	case inDownButton:	    stepsize = 1;	    break;	case inPageUp:		stepsize = -pagestep;		break;	case inPageDown:		stepsize = pagestep;;		break;	default:	    return;    }SetCtlValue(control,GetCtlValue(control) + stepsize);doscrolling();}/*----------------------------------------------------------------------*/DoSprite(){int             partcode;ControlHandle   control;GrafPtr	savePort;GetPort( &savePort );SetPort(sWindow);GlobalToLocal(&key.where);partcode = FindControl(key.where, sWindow, &control);if (partcode)	{	switch (partcode)		{		case inUpButton:		case inDownButton:			HLock(control);			TrackControl(control, key.where, trackscroll);			HUnlock(control);			break;		case inPageUp:			stepsize = -pagestep;			SetCtlValue(control,GetCtlValue(control) + stepsize);			doscrolling();			break;		case inPageDown:			stepsize = pagestep;; 			SetCtlValue(control,GetCtlValue(control) + stepsize);			doscrolling();			break;		case inThumb:			if (TrackControl(control, key.where, (Ptr)NIL))				doscrolling();		break;        }    }else	spriteAction();SetPort( savePort );}/*----------------------------------------------------------------------*/spriteAction(){Point p;Rect locate;if(plane==0||plane==3)	if(InSprite(&key.where))		MoveSprite(&locate);}/*----------------------------------------------------------------------*/Paste(){long length;long offset;int xSize,ySize;GrafPtr temp;PicHandle pict;GrafPtr	savePort;int i;if(maxsprite==128)	{	Inform("\pToo many sprites!");	return;	}GetPort( &savePort );pict=(PicHandle)NewHandle(0);length=GetScrap(pict,'PICT',&offset);if(length>0)	{	/*make room*/	for(i=maxsprite;i>locSprite;i--)CopySprite(i,i-1);	SizeRect(&xSize,&ySize,&(**pict).picFrame);	cSprite[locSprite].pict=pict;	cSprite[locSprite].clip.top=0; 	cSprite[locSprite].clip.bottom=ySize;	cSprite[locSprite].clip.left=0; 	cSprite[locSprite].clip.right=xSize;	cSprite[locSprite].locate.top=cSprite[locSprite].clip.top+16;	cSprite[locSprite].locate.bottom=cSprite[locSprite].clip.bottom+16;	cSprite[locSprite].locate.left=cSprite[locSprite].clip.left+4;	cSprite[locSprite].locate.right=cSprite[locSprite].clip.right+4;	cSprite[locSprite].fg=MakeBitMap(&cSprite[locSprite].clip);	cSprite[locSprite].mask=MakeBitMap(&cSprite[locSprite].clip);	cSprite[locSprite].bg=MakeBitMap(&cSprite[locSprite].clip);	cSprite[locSprite].used=0;	temp=(GrafPtr)NewPtr((long)sizeof(GrafPort));	OpenPort(temp);	SetPortBits(cSprite[locSprite].fg);	SetOrigin(0,0);	PenMode(patCopy);	DrawPicture(pict,&cSprite[locSprite].clip);	ClosePort(temp);	DisposPtr(temp);	CalcMask(cSprite[locSprite].fg->baseAddr,		cSprite[locSprite].mask->baseAddr,		cSprite[locSprite].fg->rowBytes,		cSprite[locSprite].mask->rowBytes,ySize,		cSprite[locSprite].fg->rowBytes/2);	SetCtlMax(sControl,maxsprite);	maxsprite++;	DrawSprite();	HiliteControl(sControl,0);	changed=TRUE;	}SetPort(savePort);}/*----------------------------------------------------------------------*/Cut(){int i;if(cSprite[locSprite].used||!maxsprite)	{	SysBeep(10);	return;	}ZeroScrap();PutScrap(GetHandleSize(cSprite[locSprite].pict),	'PICT',*cSprite[locSprite].pict);DisposHandle(cSprite[locSprite].pict);KillBitMap(cSprite[locSprite].fg);KillBitMap(cSprite[locSprite].mask);KillBitMap(cSprite[locSprite].bg);for(i=locSprite;i<maxsprite-1;i++)	CopySprite(i,i+1);maxsprite--;if(maxsprite==0){SetCtlMax(sControl,0);SetCtlValue(sControl,0);}else SetCtlMax(sControl,maxsprite-1);DrawSprite();HiliteControl(sControl,0);changed=TRUE;}/*----------------------------------------------------------------------*/Copy(){struct sprite *previous,*next,*this;if(!maxsprite)	{	SysBeep(10);	return;	}ZeroScrap();PutScrap(GetHandleSize(cSprite[locSprite].pict),	'PICT',*cSprite[locSprite].pict);}/*----------------------------------------------------------------------*/CopySprite(to,from)int to,from;{cSprite[to].pict=cSprite[from].pict;cSprite[to].clip.top=cSprite[from].clip.top; cSprite[to].clip.bottom=cSprite[from].clip.bottom;cSprite[to].clip.left=cSprite[from].clip.left; cSprite[to].clip.right=cSprite[from].clip.right;cSprite[to].locate.top=cSprite[from].locate.top;cSprite[to].locate.bottom=cSprite[from].locate.bottom;cSprite[to].locate.left=cSprite[from].locate.left;cSprite[to].locate.right=cSprite[from].locate.right;cSprite[to].fg=cSprite[from].fg;cSprite[to].mask=cSprite[from].mask;cSprite[to].bg=cSprite[from].bg;cSprite[to].used=cSprite[from].used;CopySpritenum(to,from);}/*----------------------------------------------------------------------*/DrawSprite(){Rect clip;int i;char str[100];SetPort(sWindow);SetClipRect(&clip);ClipRect(&clip);EraseRect(&clip);MoveTo(4,12);if(maxsprite)	{	if(cSprite[locSprite].used)		sprintf(str," %d/%d   In Use",locSprite+1,maxsprite);	else		sprintf(str," %d/%d",locSprite+1,maxsprite);	i=0;while(str[i])i++;str[0]=i;	DrawString(str);	DrawPicture(cSprite[locSprite].pict,&cSprite[locSprite].locate);	ClipRect(&sWindow->portRect);	}else 	{	sprintf(str,"\pNo Sprites");	DrawString(str);	MoveTo(4,26);	sprintf(str,"\pAvailable");	DrawString(str);	}}/*----------------------------------------------------------------------*/void ESprite(sp,loc)struct sprite *sp;Rect *loc;{/*CopyBits(sp->bg,offScreenBits,	&sp->clip,loc,	srcCopy,NIL);*/CopyBits(sp->bg,&screenBits,	&sp->clip,loc,	srcCopy,NIL);}/*----------------------------------------------------------------------*/void DSprite(sp,loc)struct sprite *sp;Rect *loc;{HideCursor();CopyBits(&screenBits,sp->bg,	loc,&sp->clip,	srcCopy,NIL);CopyBits(sp->mask,&screenBits,	&sp->clip,loc,	srcBic,NIL);CopyBits(sp->fg,&screenBits,	&sp->clip,loc,	srcOr,NIL);/*CopyBits(offScreenBits,&screenBits,	&screenBits.bounds,&screenBits.bounds,	srcCopy,NIL);*/ShowCursor();}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */MoveSprite(loc)Rect *loc;{Rect r,dummy;Point new,old;int i,overlap;Point p;p.v=key.where.v;p.h=key.where.h;LocalToGlobal(&key.where);CopyRect(loc,&cSprite[locSprite].locate);loc->top-=p.v-key.where.v;loc->bottom-=p.v-key.where.v;loc->left-=p.h-key.where.h;loc->right-=p.h-key.where.h;old.v=p.v;old.h=p.h;HideCursor();/*CopyBits(&screenBits,offScreenBits,	&screenBits.bounds,&screenBits.bounds,	srcCopy,NIL);*/ShowCursor();DSprite(&cSprite[locSprite],loc);while(Button())	{	GetMouse(&new);	overlap=FALSE;	if(new.v!=old.v || new.h!=old.h)		{		VWait();		ESprite(&cSprite[locSprite],loc);		MaxRect(&r,&screenBits.bounds,loc->top+new.v-old.v,			loc->left+new.h-old.h,			loc->bottom+new.v-old.v,			loc->right+new.h-old.h);		CopyRect(loc,&r);		DSprite(&cSprite[locSprite],loc);		old.v=new.v; old.h=new.h;		}	}ESprite(&cSprite[locSprite],loc);HideCursor();/*CopyBits(offScreenBits,&screenBits,	&screenBits.bounds,&screenBits.bounds,	srcCopy,NIL);*/ShowCursor();LocalToGlobal(&new);FindWindow( new, &whichWindow );if(whichWindow==theWindow)SpritePaste(loc);else if(whichWindow==animWindow)	{	if(anum!=-1)		{		if(lSprite[anum].size<8)			{			SpriteAPaste(loc);			}		}	else SysBeep(10);	}}/*--------------------------------------------------------------------- *--------------------------------------------------------------------- */int InSprite(p)Point *p;{int inside=FALSE;GrafPtr temp;GrafPtr	savePort;if(!maxsprite)return;GetPort( &savePort );temp=(GrafPtr)NewPtr((long)sizeof(GrafPort));OpenPort(temp);if(p->h>=cSprite[locSprite].locate.left &&	p->h<=cSprite[locSprite].locate.right &&	p->v>=cSprite[locSprite].locate.top &&	p->v<=cSprite[locSprite].locate.bottom)	{	SetPortBits(cSprite[locSprite].mask);	if(GetPixel(p->h-cSprite[locSprite].locate.left,p->v-cSprite[locSprite].locate.top))		{		inside=TRUE;		}	}ClosePort(temp);DisposPtr(temp);SetPort(savePort);return(inside);}