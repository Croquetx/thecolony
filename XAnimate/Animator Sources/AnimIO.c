/*--------------------------------- * The Animator * Copyright 1988 by David A. Smith * All Rights Reserved * 111 Gold Meadow Dr. * Cary, NC 27513 *---------------------------------*/#include <Quickdraw.h>#include <WindowMgr.h>#include <MenuMgr.h>#include <EventMgr.h>#include <DialogMgr.h>#include <ToolboxUtil.h>#include <ResourceMgr.h>#include <math.h>#define EXT extern#include "adefs.h"BitMap* MakeBitMap();/*--------------------------------------------------------------------- * Animation file i/o system. *--------------------------------------------------------------------- */newanim(){int i,j;/*reset background*/for(i=0;i<8;i++)newTopBG[i]=topBG[i]=ltGray[i];for(i=0;i<8;i++)newBottomBG[i]=bottomBG[i]=gray[i];if(background.active)	{	KillBitMap(background.fg); 	KillBitMap(background.mask); 	DisposHandle(background.pict);	}background.active=0;/* reset lSprites*/SetPort(animWindow);if(maxSprite)DrawInfo();for(i=0;i<maxSprite;i++)	{	for(j=0;j<lSprite[i].size;j++)		{		lSprite[i].object[j].xloc=0;		lSprite[i].object[j].yloc=0;		lSprite[i].object[j].spritenum=0;		}	KillBitMap(lSprite[i].bg);/*sprite #1 background*/	lSprite[i].visible=0;	/*visible flag*/	lSprite[i].size=0;	/*number of sprites in this object*/	lSprite[i].current=0;	/*current visible sprite*/	lSprite[i].xloc=0;	lSprite[i].yloc=0;	/*base position of object*/	lSprite[i].acurrent=0;/*animation system current visible sprite*/	lSprite[i].axloc=0;	lSprite[i].ayloc=0;	/*animation system base position of object*/	lSprite[i].type=0;	/*key or object*/	lSprite[i].frozen=0;	lSprite[i].locked=0;	lSprite[i].link=0;	lSprite[i].key=0;	lSprite[i].lock=0;	}maxSprite=0;anum=-1;/*remove simple sprites*/for(i=0;i<maxsprite;i++)	{	DisposHandle(cSprite[i].pict);	KillBitMap(cSprite[i].fg); 	KillBitMap(cSprite[i].mask); 	KillBitMap(cSprite[i].bg); 	cSprite[i].used=0;	}maxsprite=0;locSprite=0;/*Draw all of the pictures*/DrawAll();NameUntitled();}/*----------------------------------------------------------------------*/DrawAll(){DrawBGWindow();DrawSprite();if(maxsprite)SetCtlMax(sControl,maxsprite-1);else SetCtlMax(sControl,0);SetCtlValue(sControl,locSprite);HiliteControl(sControl,0);DrawBackGround(&meta0);DrawPlane();/*draw in the foreground*/DejaDCopy();DrawBackGround(&meta1);DrawAnim();AnimDCopy();}/*----------------------------------------------------------------------*/long PackBytes(src,dst,len)unsigned char *src,*dst;long len;{long i,j=0;dst[j]=1;for(i=0;i<len;i++)	{	if(src[i]==src[i+1]  && dst[j]<250)dst[j]++;	else {j++; dst[j]=src[i]; j++; dst[j]=1;}	if(j>=len)return(0L);	}return(j);}/*----------------------------------------------------------------------*/UnPackBytes(src,dst,len)unsigned char *src,*dst;long len;{long i,j=0;for(i=0;i<len;i++)	{	if((*src)==0) src+=2;	dst[i]=(*(src+1));	(*src)--;	}}/*----------------------------------------------------------------------*/savebitmap(bmap)BitMap *bmap;{long size;long bsize;char *buffer;int tf;my_write(bmap,(long)sizeof(BitMap));/*save bitmap data structure*/size=GetPtrSize(bmap->baseAddr);buffer=NewPtr(size+2);bsize=PackBytes(bmap->baseAddr,buffer,size);if(bsize)	{	tf=TRUE;	my_write(&tf,2L);	my_write(&bsize,4L);	my_write(&size,4L);	my_write(buffer,bsize);	/*{char str[255]; int i=0; 	sprintf(str," %ld %ld",bsize,size); while(str[i])i++; str[0]=i; Inform(str);}*/	}else	{	tf=FALSE;	my_write(&tf,2L);	my_write(&size,4L);	my_write(bmap->baseAddr,size);/*save data*/	}DisposPtr(buffer);}/*----------------------------------------------------------------------*/BitMap* loadbitmap(){BitMap *bmap;long size,bsize;int tf;char *buffer;bmap=(BitMap *)NewPtr((long)sizeof(BitMap));my_read(bmap,(long)sizeof(BitMap));my_read(&tf,2L);if(tf)	{	my_read(&bsize,4L);	my_read(&size,4L);	/*{char str[255]; int i=0; 	sprintf(str," %ld %ld",bsize,size); while(str[i])i++; str[0]=i; Inform(str);}*/	bmap->baseAddr = (QDPtr)NewPtr(size);	buffer=NewPtr(bsize);	my_read(buffer,bsize);	UnPackBytes(buffer,bmap->baseAddr,size);	DisposPtr(buffer);	}else	{	my_read(&size,4L);	bmap->baseAddr = (QDPtr)NewPtr(size);	my_read(bmap->baseAddr,size);	}return(bmap);}/*----------------------------------------------------------------------*/writeanim(){int i,j;/*-----------------------------Write background data*/my_write(topBG,8L);my_write(bottomBG,8L);my_write(&divideBG,2L);my_write(&background.active,2L);if(background.active)	{	my_write(&background.clip,(long)sizeof(Rect));	my_write(&background.locate,(long)sizeof(Rect));	savebitmap(background.mask);	savebitmap(background.fg); 	}/*----------------------------Write sprite data*/my_write(&maxsprite,2L);my_write(&locSprite,2L);for(i=0;i<maxsprite;i++)	{	/*cSprite[i].pict*/	savebitmap(cSprite[i].fg);	savebitmap(cSprite[i].mask);	my_write(&cSprite[i].used,2L);	my_write(&cSprite[i].clip,(long)sizeof(Rect));	my_write(&cSprite[i].locate,(long)sizeof(Rect));	}/*----------------------------Write lSprite data*/my_write(&maxSprite,2L);my_write(&anum,2L);for(i=0;i<maxSprite;i++)	{	my_write(&lSprite[i].size,2L);	for(j=0;j<lSprite[i].size;j++)		my_write(&lSprite[i].object[j],6L);	my_write(&lSprite[i].bg->bounds,(long)sizeof(Rect));	my_write(&lSprite[i].visible,2L);	/*visible flag*/	my_write(&lSprite[i].current,2L);	/*current visible sprite*/	my_write(&lSprite[i].xloc,2L);	my_write(&lSprite[i].yloc,2L);		/*base position of object*/	my_write(&lSprite[i].acurrent,2L); 	/*animation system current visible sprite*/	my_write(&lSprite[i].axloc,2L);	my_write(&lSprite[i].ayloc,2L);		/*animation system base position of object*/	my_write(&lSprite[i].type,1L);		/*key or object*/	my_write(&lSprite[i].frozen,1L);	my_write(&lSprite[i].locked,1L);	my_write(&lSprite[i].link,2L);	my_write(&lSprite[i].key,2L);		my_write(&lSprite[i].lock,2L);	}}/*----------------------------------------------------------------------*/readanim(){int i,j;/*--------------------------Read background data*/my_read(topBG,8L);my_read(bottomBG,8L);my_read(&divideBG,2L);for(i=0;i<8;i++)	{	newTopBG[i]=topBG[i];	newBottomBG[i]=bottomBG[i];	}my_read(&background.active,2L);if(background.active)	{	my_read(&background.clip,(long)sizeof(Rect));	my_read(&background.locate,(long)sizeof(Rect));	background.mask=loadbitmap();	background.fg=loadbitmap();	}/*-------------------------Read sprite data*/my_read(&maxsprite,2L);my_read(&locSprite,2L);for(i=0;i<maxsprite;i++)	{	/*cSprite[i].pict*/	cSprite[i].fg=loadbitmap(); 	cSprite[i].mask=loadbitmap();	my_read(&cSprite[i].used,2L);	cSprite[i].bg = MakeBitMap(&cSprite[i].fg->bounds);	my_read(&cSprite[i].clip,(long)sizeof(Rect));	my_read(&cSprite[i].locate,(long)sizeof(Rect));	}/*-------------------------Read lSprite data*/my_read(&maxSprite,2L);my_read(&anum,2L);for(i=0;i<maxSprite;i++)	{	Rect bounds;	my_read(&lSprite[i].size,2L);	for(j=0;j<lSprite[i].size;j++)		my_read(&lSprite[i].object[j],6L);	my_read(&bounds,(long)sizeof(Rect));	lSprite[i].bg=MakeBitMap(&bounds);	my_read(&lSprite[i].visible,2L);	/*visible flag*/	my_read(&lSprite[i].current,2L);	/*current visible sprite*/	my_read(&lSprite[i].xloc,2L);	my_read(&lSprite[i].yloc,2L);		/*base position of object*/	my_read(&lSprite[i].acurrent,2L); 	/*animation system current visible sprite*/	my_read(&lSprite[i].axloc,2L);	my_read(&lSprite[i].ayloc,2L);		/*animation system base position of object*/	my_read(&lSprite[i].type,1L);		/*key or object*/	my_read(&lSprite[i].frozen,1L);	my_read(&lSprite[i].locked,1L);	my_read(&lSprite[i].link,2L);	my_read(&lSprite[i].key,2L);	my_read(&lSprite[i].lock,2L);	}SetPort(animWindow);DrawInfo();}/*----------------------------------------------------------------------*/writepicts(fname)char *fname;{int refnum,i,err;Handle res;CreateResFile(fname);TestRes();refnum=OpenResFile(fname);TestRes();UseResFile(refnum);if(background.active)	{	AddResource(background.pict,'PICT',0,"\pbackground");	}for(i=0;i<maxsprite;i++)	{	AddResource(cSprite[i].pict,'PICT',i+1,"\psprite");	}UpdateResFile(refnum);TestRes();CloseResFile(refnum);TestRes();readpicts(fname);}/*----------------------------------------------------------------------*/readpicts(fname)char *fname;{int refnum,i;refnum=OpenResFile(fname);TestRes();UseResFile(refnum);TestRes();if(background.active)	{	background.pict=(PicHandle)Get1Resource('PICT',0);	TestRes();	DetachResource(background.pict);	TestRes();	}for(i=0;i<maxsprite;i++)	{	cSprite[i].pict=(PicHandle)Get1Resource('PICT',i+1);	TestRes();	DetachResource(cSprite[i].pict);	TestRes();	}CloseResFile(refnum);TestRes();}/*----------------------------------------------------------------------*/TestRes(){switch(ResError())	{	case 0:		break;	case -192:		Inform("\pResource not found");		break;	case -193:		Inform("\pResource file not found");		break;	case -194:		Inform("\pAddResource failed");		break;	case -196:		Inform("\pRmveResource failed");		break;	case -198:		Inform("\pProhibited operation");		break;	case -199:		Inform("\pError reading resource map");		break;	case -34:		Inform("\pDisk full error");		break;	default:		Inform("\pUnknown error");		break;	}}