/*-------------------------------------------------------------------- * readwritefile.c * * Used to load and save computer text for game. * Copyright 1987 by David A. Smith... *-------------------------------------------------------------------- */#define MAPEXT extern#include <FileMgr.h>#include <StdFilePkg.h>#include <SegmentLdr.h>#include <math.h>int		filnum;int		volnum;char	volname[255];StringPtr	filname=(StringPtr)"\pUntitled";Point putpnt,getpnt;long type='TEXT';long create='RAND';IOParam pblk;FileParam fblk;SFReply reply;AppFile theFile;/*---------------------------------------------------------------------- * * savefile(q,ch,savefun) * * q  query flag * ch change flag * savefun save function using my_write *----------------------------------------------------------------------*/int savefile(q,ch,savefun)int q,ch;void (*savefun)();{int i=0;long fsize=4096L;Point loc;OsErr err;if(q)	{	SetPt(&loc,100,80);	SFPutFile(loc  ,"\pSave File as...",pblk.ioNamePtr,(Ptr)0,&reply);	if(reply.good==FALSE)ExitToShell();	}else if(!ch)return(ch);pblk.ioNamePtr=reply.fName;pblk.ioVRefNum=reply.vRefNum;pblk.ioVersNum=reply.version;pblk.ioPermssn=fsWrPerm;pblk.ioMisc=(Ptr)0;err=PBCreate(&pblk,FALSE);if(err&&err!=dupFNErr)	{	SysBeep(10);	return(ch);	}err=PBOpen(&pblk,FALSE);if(err)	{	SysBeep(10);	return(ch);	}err=PBSetEOF(&pblk,FALSE);if(err)	{	SysBeep(10);	return(ch);	}	(*savefun)();err=PBClose(&pblk,FALSE);if(err)SysBeep(10);fblk.qLink=pblk.qLink;fblk.qType='MAP_';fblk.ioTrap=pblk.ioTrap;fblk.ioCmdAddr=pblk.ioCmdAddr;fblk.ioCompletion=pblk.ioCompletion;fblk.ioResult=pblk.ioResult;fblk.ioNamePtr=pblk.ioNamePtr;fblk.ioVRefNum=pblk.ioVRefNum;err=PBGetFInfo(&fblk,FALSE);fblk.ioFlFndrInfo.fdType=type;fblk.ioFlFndrInfo.fdCreator=create;err=PBSetFInfo(&fblk,FALSE);return(FALSE);/*indicates that data has been saved correctly*/}/*---------------------------------------------------------------------- * * openfile(q,ch,loadfun,buffer,mark) * * ch change flag * load  * loadfun load function using my_read or my_read_loc *----------------------------------------------------------------------*/char name[64];int openfile(ch,load,loadfun,buffer,mark)int ch,load;void (*loadfun)();char *buffer;long mark;{OsErr err;SFTypeList typelist;int numtypes=1;Point loc;int i=0;pblk.ioNamePtr=(StringPtr)name;if(!load)	{	SetPt(&loc,100,80);		typelist[0]='TEXT';	SFGetFile(loc,"\pLoad Map",(Ptr)0,numtypes,typelist,(Ptr)0,&reply);	if(reply.good==FALSE)ExitToShell();	for(i=0;i<64;i++)pblk.ioNamePtr[i]=reply.fName[i];	pblk.ioVRefNum=reply.vRefNum;	pblk.ioVersNum=reply.version;	pblk.ioPermssn=fsRdPerm;	pblk.ioMisc=(Ptr)0;	}else{	GetAppFiles(1,&theFile);	pblk.ioNamePtr=theFile.fName;	pblk.ioVRefNum=theFile.vRefNum;	pblk.ioVersNum=theFile.versNum;	pblk.ioPermssn=fsRdPerm;	pblk.ioMisc=(Ptr)0;	}for(i=0;i<64;i++)reply.fName[i]=pblk.ioNamePtr[i];reply.vRefNum=pblk.ioVRefNum;reply.version=pblk.ioVersNum;err=PBOpen(&pblk,FALSE);if(err)	{	SysBeep(10);	return(ch);	}(*loadfun)(buffer,mark);err=PBClose(&pblk,FALSE);if(err)SysBeep(10);return(FALSE);}/*----------------------------------------------------------------------*/my_write(buffer,length)Ptr buffer;long length;{OsErr err;pblk.ioBuffer=buffer;pblk.ioReqCount=length;pblk.ioPosMode=fsAtMark;pblk.ioPosOffset=0;err=PBWrite(&pblk,FALSE);if(err)	{	SysBeep(10);	}if(pblk.ioActCount!=pblk.ioReqCount)	{	SysBeep(10);	}}/*----------------------------------------------------------------------*/my_read(buffer,length)Ptr buffer;long length;{OsErr err;pblk.ioBuffer=buffer;pblk.ioReqCount=length;pblk.ioPosMode=fsAtMark;pblk.ioPosOffset=0;err=PBRead(&pblk,FALSE);if(err)	{	SysBeep(10);	}if(pblk.ioActCount!=pblk.ioReqCount)	{	SysBeep(10);	}}/*----------------------------------------------------------------------*/my_read_loc(buffer,length,mark)Ptr buffer;long length,mark;{OsErr err;pblk.ioBuffer=buffer;pblk.ioReqCount=length;pblk.ioPosMode=fsFromStart;pblk.ioPosOffset=mark;err=PBRead(&pblk,FALSE);if(err)	{	SysBeep(10);	}if(pblk.ioActCount!=pblk.ioReqCount)	{	SysBeep(10);	}return pblk.ioActCount;}